# 使用Spring反转控制和依赖注入简介

1.概述

在本教程中，我们将介绍IoC（控制反转）和DI（依赖注入）的概念，以及如何在Spring框架中实现这些概念。

进一步阅读：

- [ ] [Wiring in Spring: @Autowired, @Resource and @Inject](https://www.baeldung.com/spring-annotations-resource-inject-autowire)
- [ ] [@Component vs @Repository and @Service in Spring](https://www.baeldung.com/spring-component-repository-service)

2.什么是控制反转？

控制反转是软件工程中的一个原理，它将对象或程序部分的控制转移到容器或框架。我们通常在面向对象编程的上下文中使用它。

与传统编程不同，在传统编程中，我们的自定义代码调用库，IoC使框架能够控制程序流并调用自定义代码。为了实现这一点，框架使用了带有额外内置行为的抽象。如果我们想添加自己的行为，我们需要扩展框架的类或插件我们自己的类。

这种架构的优点是：

- 将任务的执行与其实现分离
- 更容易在不同的实现之间切换
- 程序的更大模块化
- 通过隔离组件或模拟其依赖项，并允许组件通过契约进行通信，从而更容易测试程序

我们可以通过各种机制实现控制反转，例如：策略设计模式 Strategy design pattern 、服务定位器模式 Service Locator pattern 、工厂模式 Factory pattern 和依赖注入 Dependency Injection (DI)。

3.什么是依赖注入？

依赖注入是一种我们可以用来实现IoC的模式，其中被反转的控件设置对象的依赖关系。

将对象与其他对象连接，或将对象“注入”到其他对象中，是由汇编程序而不是对象本身来完成的。

以下是我们如何在传统编程中创建对象依赖关系：

```java
public class Store {
    private Item item;
 
    public Store() {
        item = new ItemImpl1();    
    }
}
```

在上面的例子中，我们需要在Store类本身中实例化Item接口的实现。

通过使用DI，我们可以重写示例，而无需指定我们想要的Item的实现：

```java
public class Store {
    private Item item;
    public Store(Item item) {
        this.item = item;
    }
}
```

在接下来的部分中，我们将看看如何通过元数据提供Item的实现。

IoC和DI都是简单的概念，但它们对我们构建系统的方式有着深刻的影响，因此它们非常值得充分理解。

4.Spring IoC Container

IoC容器是实现IoC的框架的一个共同特征。

在Spring框架中，接口ApplicationContext表示IoC容器。Spring容器负责实例化、配置和组装称为bean的对象，以及管理它们的生命周期。

Spring框架提供了ApplicationContext接口的几种实现：针对独立应用程序的ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，以及针对web应用程序的WebApplicationContext。

为了组装bean，容器使用配置元数据，可以是XML配置或注释的形式。

以下是手动实例化容器的一种方法：

`ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");`

要在上面的示例中设置item属性，我们可以使用元数据。然后容器将读取此元数据，并在运行时使用它来组装bean。

Spring中的依赖注入可以通过构造函数(constructors)、setter或字段(fields)完成。

5.基于构造函数的依赖注入

在基于构造函数的依赖项注入的情况下，容器将调用一个构造函数，每个构造函数的参数表示我们想要设置的依赖项。

Spring主要按类型解析每个参数，后跟属性名和索引以消除歧义。让我们看看使用注释的bean及其依赖项的配置：

```java
@Configuration
public class AppConfig {

    @Bean
    public Item item1() {
        return new ItemImpl1();
    }

    @Bean
    public Store store() {
        return new Store(item1());
    }
}
```

@Configuration注释表明该类是bean定义的来源。我们还可以将其添加到多个配置类中。

我们在方法上使用@Bean注释来定义Bean。如果我们没有指定自定义名称，那么bean名称将默认为方法名。

对于具有默认单例(singleton)作用域的bean，Spring首先检查bean的缓存实例是否已经存在，如果不存在，则只创建一个新实例。如果我们使用原型范围，容器将为每个方法调用返回一个新的bean实例。

创建bean配置的另一种方法是通过XML配置：

```xml
<bean id="item1" class="org.baeldung.store.ItemImpl1" /> 
<bean id="store" class="org.baeldung.store.Store"> 
    <constructor-arg type="ItemImpl1" index="0" name="item" ref="item1" /> 
</bean>
```

6.基于设置程序的依赖注入

对于基于setter的DI，容器将在调用无参数构造函数(no-argument constructor)或无参数静态工厂方法(no-argument static factory)来实例化bean后调用类的setter方法。让我们使用注释创建此配置：

```java
@Bean
public Store store() {
    Store store = new Store();
    store.setItem(item1());
    return store;
}
```

我们还可以将XML用于相同的bean配置：

```java
<bean id="store" class="org.baeldung.store.Store">
    <property name="item" ref="item1" />
</bean>
```

我们可以为同一bean组合基于构造函数和基于setter的注入类型。Spring文档建议对强制依赖项使用基于构造函数的注入，而对可选依赖项则使用基于setter的注入。

7.基于字段的依赖注入

对于基于字段的DI，我们可以通过使用@Autowired注释标记依赖项来注入依赖项：

```java
public class Store {
    @Autowired
    private Item item; 
}
```

在构造Store对象时，如果没有构造函数或setter方法来注入Itembean，容器将使用反射将Item注入Store。

我们还可以使用XML配置来实现这一点。

这种方法可能看起来更简单、更干净，但我们不建议使用，因为它有一些缺点，例如：

此方法使用反射来注入依赖项，这比基于构造函数或基于setter的注入成本更高。
使用这种方法可以很容易地添加多个依赖项。如果我们使用构造函数注入，有多个参数会让我们认为类做了不止一件事，这可能违反单一责任原则。
有关@Autowired注释的更多信息，请参阅[Wiring in Spring](https://www.baeldung.com/spring-annotations-resource-inject-autowire)文章。

8.Autowiring Dependencies

连线允许Spring容器通过检查已定义的bean来自动解决协作bean之间的依赖关系。

使用XML配置自动连接bean有四种模式：

- no：默认值，这意味着bean不使用自动连接，我们必须显式地命名依赖项。
- byName：自动连接是基于属性的名称进行的，因此Spring将查找与需要设置的属性同名的bean。
- byType：类似于byName自动连线，仅基于属性的类型。这意味着Spring将查找具有相同类型属性的bean来设置。如果该类型的bean不止一个，框架将抛出异常。
- constructor：自动连接是基于构造函数参数完成的，这意味着Spring将查找与构造函数参数具有相同类型的bean。

例如，让我们将上面通过类型定义的 item1 bean自动连接到存储bean：

```java
@Bean(autowire = Autowire.BY_TYPE)
public class Store {
    
    private Item item;

    public setItem(Item item){
        this.item = item;    
    }
}
```

我们还可以使用@Autowired注释按类型自动连接bean：

```java
public class Store {
    @Autowired
    private Item item;
}
```

如果有多个相同类型的bean，我们可以使用@Qualifier注释按名称引用bean：

```java
public class Store {
    @Autowired
    @Qualifier("item1")
    private Item item;
}
```

现在，让我们通过XML配置按类型自动连接bean：

`<bean id="store" class="org.baeldung.store.Store" autowire="byType"> </bean>`

接下来，让我们通过XML将一个名为item的bean按名称注入store bean的item属性：

```xml
<bean id="item" class="org.baeldung.store.ItemImpl1" />
<bean id="store" class="org.baeldung.store.Store" autowire="byName">
</bean>
```

我们还可以通过构造函数参数或setter显式定义依赖项来覆盖自动连接。

9.惰性初始化Bean

默认情况下，容器在初始化期间创建和配置所有单例bean。为了避免这种情况，我们可以在bean配置中使用值为true的lazy-init属性：

`<bean id="item1" class="org.baeldung.store.ItemImpl1" lazy-init="true" />`

因此，item1bean将仅在首次请求时初始化，而不是在启动时初始化。这样做的优点是更快的初始化时间，但代价是，在请求bean之前，我们不会发现任何配置错误，这可能是在应用程序已经运行几个小时甚至几天之后。

10.结论

在本文中，我们介绍了控制反转和依赖注入的概念，并在Spring框架中举例说明。

了解更多关于这些概念的信息：

- [x] [控制容器的反转和依赖注入模式](http://martinfowler.com/articles/injection.html)
  - [翻译](https://insights.thoughtworks.cn/injection/)
- [x] [控制反转](http://martinfowler.com/bliki/InversionOfControl.html)

此外，我们可以在[Spring框架参考文档](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-dependencies)中了解IoC和DI的Spring实现。
