# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

deltaManager.createSession.newSession=Created a DeltaSession with Id [{0}] Total count={1}
deltaManager.createMessage.access=Manager [{0}]: create session message [{1}] access.
deltaManager.createMessage.accessChangePrimary=Manager [{0}]: create session message [{1}] access to change primary.
deltaManager.createMessage.allSessionData=Manager [{0}] send all session data.
deltaManager.createMessage.allSessionTransfered=Manager [{0}] send all session data transfered
deltaManager.createMessage.delta=Manager [{0}]: create session message [{1}] delta request.
deltaManager.createMessage.expire=Manager [{0}]: create session message [{1}] expire.
deltaManager.createMessage.unableCreateDeltaRequest=Unable to serialize delta request for sessionid [{0}]
deltaManager.dropMessage=Manager [{0}]: Drop message {1} inside GET_ALL_SESSIONS sync phase start date {2} message date {3}
deltaManager.foundMasterMember=Found for context [{0}] the replication master member [{1}]
deltaManager.loading.cnfe=ClassNotFoundException while loading persisted sessions: {0}
deltaManager.loading.existing.session=overload existing session {0}
deltaManager.loading.ioe=IOException while loading persisted sessions: {0}
deltaManager.loading.withContextClassLoader=Manager [{0}]: Loading the object data with a context class loader.
deltaManager.loading.withoutClassLoader=Manager [{0}]: Loading the object data without a context class loader.
deltaManager.managerLoad=Exception loading sessions from persistent storage
deltaManager.noCluster=Starting... no cluster associated with this context: [{0}]
deltaManager.noMasterMember=Starting... with no other member for context [{0}] at domain [{1}]
deltaManager.noMembers=Manager [{0}]: skipping state transfer. No members active in cluster group.
deltaManager.noSessionState=Manager [{0}]: No session state send at {1} received, timing out after {2} ms.
deltaManager.noContextManager=Manager [{0}]: No context manager send at {1} received in {2} ms.
deltaManager.sendMessage.newSession=Manager [{0}] send new session ({1})
deltaManager.expireSessions=Manager [{0}] expiring sessions upon shutdown
deltaManager.receiveMessage.accessed=Manager [{0}]: received session [{1}] accessed.
deltaManager.receiveMessage.createNewSession=Manager [{0}]: received session [{1}] created.
deltaManager.receiveMessage.delta=Manager [{0}]: received session [{1}] delta.
deltaManager.receiveMessage.error=Manager [{0}]: Unable to receive message through TCP channel
deltaManager.receiveMessage.eventType=Manager [{0}]: Received SessionMessage of type=({1}) from [{2}]
deltaManager.receiveMessage.expired=Manager [{0}]: received session [{1}] expired.
deltaManager.receiveMessage.transfercomplete=Manager [{0}] received from node [{1}:{2}] session state transfered.
deltaManager.receiveMessage.noContextManager=Manager [{0}] received from node [{1}:{2}] no context manager.
deltaManager.receiveMessage.unloadingAfter=Manager [{0}]: unloading sessions complete
deltaManager.receiveMessage.unloadingBegin=Manager [{0}]: start unloading sessions
deltaManager.receiveMessage.allSessionDataAfter=Manager [{0}]: session state deserialized
deltaManager.receiveMessage.allSessionDataBegin=Manager [{0}]: received session state data
deltaManager.registerCluster=Register manager {0} to cluster element {1} with name {2}
deltaManager.sessionReceived=Manager [{0}]; session state send at {1} received in {2} ms.
deltaManager.startClustering=Starting clustering manager at {0}
deltaManager.stopped=Manager [{0}] is stopping
deltaManager.unloading.ioe=IOException while saving persisted sessions: {0}
deltaManager.waitForSessionState=Manager [{0}], requesting session state from {1}. This operation will timeout if no session state has been received within {2} seconds.
deltaManager.unableSerializeSessionID =Unable to serialize sessionID [{0}]
deltaRequest.showPrincipal=Principal [{0}] is set to session {1}
deltaRequest.wrongPrincipalClass=ClusterManager only support GenericPrincipal. Your realm used principal class {0}.
deltaSession.notifying=Notifying cluster of expiration primary={0} sessionId [{1}]
deltaSession.valueBound.ex=Session bound listener throw an exception
deltaSession.valueBinding.ex=Session binding listener throw an exception
deltaSession.valueUnbound.ex=Session unbound listener throw an exception
deltaSession.readSession=readObject() loading session [{0}]
deltaSession.readAttribute=session [{0}] loading attribute [{1}] with value [{2}]
deltaSession.writeSession=writeObject() storing session [{0}]
jvmRoute.cannotFindSession=Can''t find session [{0}]
jvmRoute.changeSession=Changed session from [{0}] to [{1}]
jvmRoute.clusterListener.started=Cluster JvmRouteSessionIDBinderListener started
jvmRoute.clusterListener.stopped=Cluster JvmRouteSessionIDBinderListener stopped
jvmRoute.configure.warn=Please, setup your JvmRouteBinderValve at host valve, not at context valve!
jvmRoute.contextNotFound=Context [{0}] not found at node [{1}]!
jvmRoute.failover=Detected a failover with different jvmRoute - orginal route: [{0}] new one: [{1}] at session id [{2}]
jvmRoute.foundManager=Found Cluster Manager {0} at {1}
jvmRoute.hostNotFound=No host found [{0}]
jvmRoute.listener.started=SessionID Binder Listener started
jvmRoute.listener.stopped=SessionID Binder Listener stopped
jvmRoute.lostSession=Lost Session [{0}] at path [{1}]
jvmRoute.missingJvmRouteAttribute=No engine jvmRoute attribute configured!
jvmRoute.newSessionCookie=Setting cookie with session id [{0}] name: [{1}] path: [{2}] secure: [{3}] httpOnly: [{4}]
jvmRoute.noCluster=The JvmRouterBinderValve is configured, but clustering is not being used. Fail over will still work, providing a PersistentManager is used.
jvmRoute.notFoundManager=Not found Cluster Manager at {0}
jvmRoute.receiveMessage.sessionIDChanged=Cluster JvmRouteSessionIDBinderListener received orginal session ID [{0}] set to new id [{1}] for context path [{2}]
jvmRoute.run.already=jvmRoute SessionID receiver run already
jvmRoute.skipURLSessionIDs=Skip reassign jvm route check, sessionid comes from URL!
jvmRoute.turnoverInfo=Turnover Check time {0} msec
jvmRoute.valve.started=JvmRouteBinderValve started
jvmRoute.valve.stopped=JvmRouteBinderValve stopped
jvmRoute.set.orignalsessionid=Set Orginal Session id at request attribute {0} value: {1}
standardSession.notSerializable=Cannot serialize session attribute {0} for session {1}
standardSession.removeAttribute.ise=removeAttribute: Session already invalidated
standardSession.setAttribute.namenull=setAttribute: name parameter cannot be null
serializablePrincipal.readPrincipal.cnfe=readPrincipal: Failed to recreate user Principal
backupManager.noCluster=no cluster associated with this context: [{0}]
backupManager.startUnable=Unable to start BackupManager: [{0}]
backupManager.startFailed=Failed to start BackupManager: [{0}]
backupManager.stopped=Manager [{0}] is stopping
