package com.baeldung.gcp.firebase.firestore;

import static org.assertj.core.api.Assertions.assertThat;
import static org.instancio.Select.field;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.instancio.Instancio;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;
import org.testcontainers.containers.FirestoreEmulatorContainer;
import org.testcontainers.shaded.org.awaitility.Awaitility;
import org.testcontainers.utility.DockerImageName;

import com.google.cloud.NoCredentials;
import com.google.cloud.firestore.DocumentReference;
import com.google.cloud.firestore.DocumentSnapshot;
import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.FirestoreOptions;
import com.google.cloud.firestore.QueryDocumentSnapshot;

import net.bytebuddy.utility.RandomString;

@SpringBootTest
@ActiveProfiles("live-test")
class TaskCrudLiveTest {

    @Autowired
    private Firestore firestore;

    private static FirestoreEmulatorContainer firestoreEmulatorContainer = new FirestoreEmulatorContainer(
        DockerImageName.parse("gcr.io/google.com/cloudsdktool/google-cloud-cli:488.0.0-emulators")
    );

    @TestConfiguration
    static class FirestoreTestConfiguration {

        @Bean
        public Firestore firestore() {
            firestoreEmulatorContainer.start();
            FirestoreOptions options = FirestoreOptions
                .getDefaultInstance()
                .toBuilder()
                .setProjectId(RandomString.make().toLowerCase())
                .setCredentials(NoCredentials.getInstance())
                .setHost(firestoreEmulatorContainer.getEmulatorEndpoint())
                .build();
            return options.getService();
        }

    }

    @Test
    void whenCreatingTask_thenTaskIsSavedInFirestoreWithAutoGeneratedId() throws Exception {
        // Set up test data
        Task task = Instancio.create(Task.class);

        // Save task in Firestore
        DocumentReference taskReference = firestore
            .collection(Task.PATH)
            .document();
        taskReference.set(task);

        // Verify task is saved with auto-generated ID
        String taskId = taskReference.getId();
        assertThat(taskId).isNotBlank();
        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAsserted(() -> {
            DocumentSnapshot taskSnapshot = firestore
                .collection(Task.PATH)
                .document(taskId)
                .get().get();
            assertThat(taskSnapshot.exists())
                .isTrue();
        });
    }

    @Test
    void whenCreatingTaskWithCustomTaskId_thenTaskIsSavedInFirestore() throws Exception {
        // Set up test data
        Task task = Instancio.create(Task.class);
        String taskId = Instancio.create(String.class);

        // Save task in Firestore with custom ID
        firestore
            .collection(Task.PATH)
            .document(taskId)
            .set(task);

        // Verify task is saved
        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAsserted(() -> {
            DocumentSnapshot taskSnapshot = firestore
                .collection(Task.PATH)
                .document(taskId)
                .get().get();
            assertThat(taskSnapshot.exists())
                .isTrue();
        });
    }

    @Test
    void whenRetrievingExistingTask_thenCorrectTaskIsReturned() throws Exception {
        // Set up test data
        Task task = Instancio.create(Task.class);
        String taskId = Instancio.create(String.class);

        // Save task in Firestore
        firestore
            .collection(Task.PATH)
            .document(taskId)
            .set(task)
            .get();

        // Retrieve the task
        DocumentSnapshot taskSnapshot = firestore
            .collection(Task.PATH)
            .document(taskId)
            .get().get();

        // Verify correct task is retrieved
        Task retrievedTask = taskSnapshot.toObject(Task.class);
        assertThat(retrievedTask)
            .usingRecursiveComparison()
            .isEqualTo(task);
    }

    @Test
    void whenRetrievingTasksWithStatusQuery_thenMatchingTasksAreReturned() throws Exception {
        // Set up test data
        Task completedTask = Instancio.of(Task.class)
            .set(field(Task::getStatus), "COMPLETED")
            .create();
        Task inProgressTask = Instancio.of(Task.class)
            .set(field(Task::getStatus), "IN_PROGRESS")
            .create();
        Task anotherCompletedTask = Instancio.of(Task.class)
            .set(field(Task::getStatus), "COMPLETED")
            .create();
        List<Task> tasks = List.of(completedTask, inProgressTask, anotherCompletedTask);

        // Save tasks in Firestore
        for (Task task: tasks) {
            firestore
                .collection(Task.PATH)
                .add(task)
                .get();
        }

        // Retrieve completed tasks
        List<QueryDocumentSnapshot> retrievedTaskSnapshots = firestore
            .collection(Task.PATH)
            .whereEqualTo("status", "COMPLETED")
            .get().get().getDocuments();

        // Verify only matching tasks are retrieved
        List<Task> retrievedTasks = retrievedTaskSnapshots
            .stream()
            .map(snapshot -> snapshot.toObject(Task.class))
            .toList();
        assertThat(retrievedTasks)
            .usingRecursiveFieldByFieldElementComparator()
            .containsExactlyInAnyOrder(completedTask, anotherCompletedTask);
    }

    @Test
    @DirtiesContext
    void whenRetrievingTaskDueWithinNextWeek_thenCorrectTaskIsReturned() throws Exception {
        // Create task with due date within a week
        Date dueDate = Date.from(Instant.now().plus(5, ChronoUnit.DAYS));
        Task task = Instancio.of(Task.class)
            .set(field(Task::getDueDate), dueDate)
            .create();
        firestore
            .collection(Task.PATH)
            .add(task)
            .get();

        // Retrieve tasks due within the next week
        List<QueryDocumentSnapshot> retrievedTaskSnapshots = firestore
            .collection(Task.PATH)
            .whereGreaterThanOrEqualTo("dueDate", Date.from(Instant.now()))
            .whereLessThanOrEqualTo("dueDate", Date.from(Instant.now().plus(7, ChronoUnit.DAYS)))
            .get().get().getDocuments();

        // Verify the correct task is retrieved
        assertThat(retrievedTaskSnapshots)
            .hasSize(1)
            .map(snapshot -> snapshot.toObject(Task.class))
            .first()
            .satisfies(retrievedTask -> {
                assertThat(retrievedTask)
                    .usingRecursiveComparison()
                    .isEqualTo(task);
            });
    }

    @Test
    void whenUpdatingTask_thenTaskIsUpdatedInFirestore() throws Exception {
        // Save initial task in Firestore
        String taskId = Instancio.create(String.class);
        Task initialTask = Instancio.of(Task.class)
            .set(field(Task::getStatus), "IN_PROGRESS")
            .create();
        firestore
            .collection(Task.PATH)
            .document(taskId)
            .set(initialTask);

        // Ensure the task is created
        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAsserted(() -> {
            DocumentSnapshot taskSnapshot = firestore
                .collection(Task.PATH)
                .document(taskId)
                .get().get();
            assertThat(taskSnapshot.exists())
                .isTrue();
        });

        // Update the task
        Task updatedTask = initialTask;
        updatedTask.setStatus("COMPLETED");
        firestore
            .collection(Task.PATH)
            .document(taskId)
            .set(initialTask);

        // Verify the task was updated correctly
        Task retrievedTask = firestore
            .collection(Task.PATH)
            .document(taskId)
            .get().get()
            .toObject(Task.class);
        assertThat(retrievedTask)
            .usingRecursiveComparison()
            .isNotEqualTo(initialTask)
            .ignoringFields("status")
            .isEqualTo(initialTask);
    }

    @Test
    void whenDeletingTask_thenTaskIsRemovedFromFirestore() throws Exception {
        // Save task in Firestore
        Task task = Instancio.create(Task.class);
        String taskId = Instancio.create(String.class);
        firestore
            .collection(Task.PATH)
            .document(taskId)
            .set(task);

        // Ensure the task is created
        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAsserted(() -> {
            DocumentSnapshot taskSnapshot = firestore
                .collection(Task.PATH)
                .document(taskId)
                .get().get();
            assertThat(taskSnapshot.exists())
                .isTrue();
        });

        // Delete the task
        firestore
            .collection(Task.PATH)
            .document(taskId)
            .delete();

        // Assert that the task is deleted
        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAsserted(() -> {
            DocumentSnapshot taskSnapshot = firestore
                .collection(Task.PATH)
                .document(taskId)
                .get().get();
            assertThat(taskSnapshot.exists())
                .isFalse();
        });
    }

}