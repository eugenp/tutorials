package org.baeldung.HibernateAuditDemo;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import java.util.Calendar;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

import org.baeldung.HibernateAuditDemo.model.Customer;
import org.baeldung.HibernateAuditDemo.model.Order;
import org.hibernate.envers.AuditReader;
import org.hibernate.envers.AuditReaderFactory;
import org.hibernate.envers.DefaultRevisionEntity;
import org.hibernate.envers.RevisionType;
import org.hibernate.envers.query.AuditEntity;
import org.hibernate.envers.query.AuditQuery;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * Illustrates how to use Envers.
 */
public class EnversTest {
    private static EntityManagerFactory entityManagerFactory;

    @BeforeClass
    public static void setUp() throws Exception {
        entityManagerFactory = Persistence.createEntityManagerFactory("enversPU");

        // populate db with Orders and Customers before test methods. Id is generated by increment strategy thus it's always 1,2,3
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();

        Customer customer1 = new Customer("Jhon Smith");
        Customer customer2 = new Customer("Mike Thompson");
        entityManager.persist(customer1);
        entityManager.persist(customer2);

        entityManager.persist(new Order(23.12, Calendar.getInstance(), customer1));
        entityManager.persist(new Order(45.34, Calendar.getInstance(), customer2));
        entityManager.persist(new Order(12.14, Calendar.getInstance()));

        entityManager.getTransaction().commit();
        entityManager.close();

        // updating Orders. This causes envers to create and store revisions about change
        entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();

        // first Order has id 1
        Order order1 = entityManager.find(Order.class, 1l);
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DAY_OF_MONTH, 5);
        order1.setCreatedDate(calendar);
        order1.setPrice(order1.getPrice() + 100);

        Order order2 = entityManager.find(Order.class, 2l);
        order2.setPrice(order2.getPrice() + 11);

        entityManager.getTransaction().commit();
        entityManager.close();
    }

    @AfterClass
    public static void close() throws Exception {
        entityManagerFactory.close();
    }

    /**
     * This method updates Order entity with id 1. Then it reads 2 revisions(create and update) of this entity.  
     */
    @Test
    public void testFindEntityByPKAtGivenRevisionNumber() {
        long orderId = 1;

        // querying for Order entity from revisions
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();

        Order order = entityManager.find(Order.class, orderId);

        // to read entity from revision we use AuditReader
        AuditReader reader = AuditReaderFactory.get(entityManager);

        // Find Entity By PK At Given RevisionNumber
        // firstRevision contains data on persist
        Order firstRevision = reader.find(Order.class, orderId, 1);
        assertThat(firstRevision.getPrice(), not(equalTo(order.getPrice())));
        assertThat(firstRevision.getCreatedDate(), not(equalTo(order.getCreatedDate())));

        // secondRevision contains data on update
        Order secondRevision = reader.find(Order.class, orderId, 2);
        assertThat(secondRevision.getPrice(), equalTo(order.getPrice()));
        assertThat(secondRevision.getCreatedDate(), equalTo(order.getCreatedDate()));

        entityManager.getTransaction().commit();
        entityManager.close();
    }

    /**
     * This method queries for revisions of entity identified by id. Then revions's id, date and entity is printed to console.
     */
    @Test
    public void testFindRevisionsForEntityWithGivenPK() {
        long orderId = 1;
        // querying db for revisions
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();

        Order order = entityManager.find(Order.class, orderId);

        AuditReader auditReader = AuditReaderFactory.get(entityManager);

        AuditQuery auditQuery = auditReader.createQuery().forRevisionsOfEntity(Order.class, false, true);
        // add criteria to filter revisions by entity's id
        List revisions = auditQuery.add(AuditEntity.id().eq(orderId)).getResultList();

        for (Object revision : revisions) {
            Object[] history = (Object[]) revision;

            Object entity = history[0];// Order entity itself
            DefaultRevisionEntity revisionEntity = (DefaultRevisionEntity) history[1];// Revision entity itself

            assertTrue(order.equals(entity));

            System.out.println("Revision: " + revisionEntity.getId());
            System.out.println("Entity at revision: " + entity);
        }

        entityManager.getTransaction().commit();
        entityManager.close();
    }

    @Test
    public void testFindEntitiesForRevisionAndOrderThem() {
        // querying db for entities
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();

        Order order = entityManager.find(Order.class, 3l);

        AuditReader auditReader = AuditReaderFactory.get(entityManager);
        // find Order entity with max id
        Object lastInsertedOrder = auditReader.createQuery().forEntitiesAtRevision(Order.class, 1).addOrder(AuditEntity.property("id").desc()).setMaxResults(1).getSingleResult();

        assertThat(order, equalTo(lastInsertedOrder));
        System.out.println("lastInsertedOrder=" + lastInsertedOrder);

        entityManager.getTransaction().commit();
        entityManager.close();
    }

    /**
     * Finds revision at which Order entity has changed its property price. To do this you must set @Audited(withModifiedFlag = true) on property price.
     */
    @Test
    public void testFindRevisionAtWhichPropertyChanged() {

        EntityManager entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();

        Order order = entityManager.find(Order.class, 1l);

        AuditReader auditReader = AuditReaderFactory.get(entityManager);
        // find entities which changed its property price. It's possible because of @Audited(withModifiedFlag = true) on property 'price'
        List entities = auditReader.createQuery().forRevisionsOfEntity(Order.class, false, true).add(AuditEntity.property("price").hasChanged()).getResultList();

        for (Object object : entities) {
            Object[] history = (Object[]) object;
            // history[2] contains revision type
            if (history[2] == RevisionType.MOD)
                System.out.println("Entity with modified price: " + history[0]);
        }

        entityManager.getTransaction().commit();
        entityManager.close();
    }

    /**
     * Makes use of org.hibernate.envers.track_entities_changed_in_revision property. It reads changes to entities and groups them by {@link RevisionType}.
     * This method prints entities(mapped to revision type) for first and second revisions.
     */
    @Test
    public void testFindEntitiesMappedToRevTypeInGivenRevNumber() {
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();

        AuditReader auditReader = AuditReaderFactory.get(entityManager);
        // maps entities to revision types at revision number 1
        Map<RevisionType, List<Object>> entitiesByRevisionType = auditReader.getCrossTypeRevisionChangesReader().findEntitiesGroupByRevisionType(1);
        assertThat(entitiesByRevisionType.get(RevisionType.ADD).size(), equalTo(5));

        System.out.println("Revision 1:");
        printMap(entitiesByRevisionType);

        entitiesByRevisionType = auditReader.getCrossTypeRevisionChangesReader().findEntitiesGroupByRevisionType(2);
        assertThat(entitiesByRevisionType.get(RevisionType.MOD).size(), equalTo(2));

        System.out.println("Revision 2:");
        printMap(entitiesByRevisionType);

        entityManager.getTransaction().commit();
        entityManager.close();
    }

    private void printMap(Map<RevisionType, List<Object>> entitiesByRevisionType) {
        Set<RevisionType> revisionTypes = entitiesByRevisionType.keySet();
        for (RevisionType revisionType : revisionTypes) {
            List<Object> entities = entitiesByRevisionType.get(revisionType);
            System.out.println(revisionType);
            System.out.println(entities);
        }
    }

    /**
     * Finds revisions by related entity. If given Customer object is equal to Order.customer, it returns all versions of that Order.    
     */
    @Test
    public void testFindEntityByRelatedEntityProperty() {
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();

        AuditReader auditReader = AuditReaderFactory.get(entityManager);
        // returns entity with id 1 but two versions : after insert and after update
        List entity = auditReader.createQuery().forRevisionsOfEntity(Order.class, true, true).add(AuditEntity.property("customer").eq(new Customer(1l, "Jhon Smith"))).getResultList();

        System.out.println("entity=" + entity);

        entityManager.getTransaction().commit();
        entityManager.close();
    }
}
